var search_data = {"index":{"searchIndex":["mime","type","invalidcontenttype","invalidencoding","types","cache","container","loader","<=>()","[]()","__types__()","add()","add_extensions()","add_type()","add_type_variant!()","ascii?()","binary?()","cache_file()","complete?()","content_type=()","count()","default_encoding()","each()","eql?()","from_array()","from_hash()","from_mime_type()","index_extensions!()","json_path()","lazy_load?()","like?()","load()","load()","load_default_mime_types()","load_from_file()","load_from_json()","load_from_v1()","load_from_yaml()","load_json()","load_v1()","load_yaml()","match()","new()","new()","new()","obsolete?()","of()","platform?()","priority_compare()","prune_matches()","read_file()","registered?()","save()","signature?()","system()","system?()","to_a()","to_h()","to_hash()","to_json()","to_s()","to_str()","type_for()","urls()","use_instead()","v1_path()","xref_urls()","yaml_path()","contributing","history-types","history","licence","manifest","readme","copying","artistic"],"longSearchIndex":["mime","mime::type","mime::type::invalidcontenttype","mime::type::invalidencoding","mime::types","mime::types::cache","mime::types::container","mime::types::loader","mime::type#<=>()","mime::types#[]()","mime::types#__types__()","mime::types#add()","mime::type#add_extensions()","mime::types#add_type()","mime::types#add_type_variant!()","mime::type#ascii?()","mime::type#binary?()","mime::types#cache_file()","mime::type#complete?()","mime::type#content_type=()","mime::types#count()","mime::type#default_encoding()","mime::types#each()","mime::type#eql?()","mime::type#from_array()","mime::type#from_hash()","mime::type#from_mime_type()","mime::types#index_extensions!()","mime::types::loader#json_path()","mime::types#lazy_load?()","mime::type#like?()","mime::types::cache#load()","mime::types::loader#load()","mime::types#load_default_mime_types()","mime::types#load_from_file()","mime::types::loader#load_from_json()","mime::types::loader#load_from_v1()","mime::types::loader#load_from_yaml()","mime::types::loader#load_json()","mime::types::loader#load_v1()","mime::types::loader#load_yaml()","mime::types#match()","mime::type::new()","mime::types::new()","mime::types::loader::new()","mime::type#obsolete?()","mime::types#of()","mime::type#platform?()","mime::type#priority_compare()","mime::types#prune_matches()","mime::types::loader#read_file()","mime::type#registered?()","mime::types::cache#save()","mime::type#signature?()","mime::type#system()","mime::type#system?()","mime::type#to_a()","mime::type#to_h()","mime::type#to_hash()","mime::type#to_json()","mime::type#to_s()","mime::type#to_str()","mime::types#type_for()","mime::type#urls()","mime::type#use_instead()","mime::types::loader#v1_path()","mime::type#xref_urls()","mime::types::loader#yaml_path()","","","","","","","",""],"info":[["MIME","","MIME.html","",""],["MIME::Type","","MIME/Type.html","","<p>The definition of one MIME content-type.\n<p>Usage\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">'mime/types'</span>\n\n<span class=\"ruby-identifier\">plaintext</span> = <span class=\"ruby-constant\">MIME</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Types</span>[<span class=\"ruby-string\">'text/plain'</span>].<span class=\"ruby-identifier\">first</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["MIME::Type::InvalidContentType","","MIME/Type/InvalidContentType.html","","<p>Reflects a MIME content-type specification that is not correctly formatted\n(it isn’t <code>type</code>/<code>subtype</code>).\n"],["MIME::Type::InvalidEncoding","","MIME/Type/InvalidEncoding.html","","<p>Reflects an unsupported MIME encoding.\n"],["MIME::Types","","MIME/Types.html","","<p>MIME::Types is a registry of MIME types. It is both a class (created with\nMIME::Types.new) and a default …\n"],["MIME::Types::Cache","","MIME/Types/Cache.html","",""],["MIME::Types::Container","","MIME/Types/Container.html","",""],["MIME::Types::Loader","","MIME/Types/Loader.html","","<p>This class is responsible for initializing the MIME::Types registry from\nthe data files supplied with …\n"],["<=>","MIME::Type","MIME/Type.html#method-i-3C-3D-3E","(other)","<p>Compares the MIME::Type against the exact content type or the simplified\ntype (the simplified type will …\n"],["[]","MIME::Types","MIME/Types.html#method-i-5B-5D","(type_id, flags = {})","<p>Returns a list of MIME::Type objects, which may be empty. The optional flag\nparameters are <code>:complete</code> …\n"],["__types__","MIME::Types","MIME/Types.html#method-i-__types__","()",""],["add","MIME::Types","MIME/Types.html#method-i-add","(*types)","<p>Add one or more MIME::Type objects to the set of known types. If the type\nis already known, a warning …\n"],["add_extensions","MIME::Type","MIME/Type.html#method-i-add_extensions","(*ext)","<p>Merge the extensions provided into this MIME::Type. The extensions added\nwill be merged uniquely.\n"],["add_type","MIME::Types","MIME/Types.html#method-i-add_type","(mime_type, quiet = false)","<p>Add a single MIME::Type object to the set of known types. If the type is\nalready known, a warning will …\n"],["add_type_variant!","MIME::Types","MIME/Types.html#method-i-add_type_variant-21","(mime_type)",""],["ascii?","MIME::Type","MIME/Type.html#method-i-ascii-3F","()","<p>MIME types can be specified to be sent across a network in particular\nformats. This method returns <code>false</code> …\n"],["binary?","MIME::Type","MIME/Type.html#method-i-binary-3F","()","<p>MIME types can be specified to be sent across a network in particular\nformats. This method returns <code>true</code> …\n"],["cache_file","MIME::Types","MIME/Types.html#method-i-cache_file","()","<p>Returns the currently defined cache file, if any.\n"],["complete?","MIME::Type","MIME/Type.html#method-i-complete-3F","()","<p>Returns <code>true</code> if the MIME::Type specifies an extension list,\nindicating that it is a complete MIME::Type …\n"],["content_type=","MIME::Type","MIME/Type.html#method-i-content_type-3D","(type_string)",""],["count","MIME::Types","MIME/Types.html#method-i-count","()","<p>Returns the number of known type variants.\n"],["default_encoding","MIME::Type","MIME/Type.html#method-i-default_encoding","()","<p>Returns the default encoding for the MIME::Type based on the media type.\n"],["each","MIME::Types","MIME/Types.html#method-i-each","()","<p>Iterates through the type variants.\n"],["eql?","MIME::Type","MIME/Type.html#method-i-eql-3F","(other)","<p>Returns <code>true</code> if the other object is a MIME::Type and the\ncontent types match.\n"],["from_array","MIME::Type","MIME/Type.html#method-i-from_array","(*args)","<p>Creates a MIME::Type from an array in the form of:\n\n<pre>[type-name, [extensions], encoding, system]</pre>\n<p><code>extensions</code> ...\n"],["from_hash","MIME::Type","MIME/Type.html#method-i-from_hash","(hash)","<p>Creates a MIME::Type from a hash. Keys are case-insensitive, dashes may be\nreplaced with underscores, …\n"],["from_mime_type","MIME::Type","MIME/Type.html#method-i-from_mime_type","(mime_type)","<p>Essentially a copy constructor.\n\n<pre>MIME::Type.from_mime_type(plaintext)</pre>\n<p>is equivalent to:\n"],["index_extensions!","MIME::Types","MIME/Types.html#method-i-index_extensions-21","(mime_type)",""],["json_path","MIME::Types::Loader","MIME/Types/Loader.html#method-i-json_path","()",""],["lazy_load?","MIME::Types","MIME/Types.html#method-i-lazy_load-3F","()",""],["like?","MIME::Type","MIME/Type.html#method-i-like-3F","(other)","<p>Returns <code>true</code> if the simplified type matches the current\n"],["load","MIME::Types::Cache","MIME/Types/Cache.html#method-i-load","(cache_file = nil)","<p>Attempts to load the cache from the file provided as a parameter or in the\nenvironment variable <code>RUBY_MIME_TYPES_CACHE</code> …\n"],["load","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load","()",""],["load_default_mime_types","MIME::Types","MIME/Types.html#method-i-load_default_mime_types","()",""],["load_from_file","MIME::Types","MIME/Types.html#method-i-load_from_file","(filename)","<p>Load MIME::Types from a v1 file registry.\n<p>This method has been deprecated.\n"],["load_from_json","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_from_json","(filename)","<p>Loads MIME::Types from a single JSON file.\n<p>It is expected that the JSON objects will be an array of hash …\n"],["load_from_v1","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_from_v1","(filename)","<p>Build the type list from a file in the format:\n\n<pre>[*][!][os:]mt/st[&lt;ws&gt;@ext][&lt;ws&gt;:enc][&lt;ws&gt;'url-list][&lt;ws&gt;=docs]</pre>\n"],["load_from_yaml","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_from_yaml","(filename)","<p>Loads MIME::Types from a single YAML file.\n<p>It is expected that the YAML objects contained within the registry …\n"],["load_json","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_json","()","<p>Loads a MIME::Types registry from JSON files (<code>*.json</code>)\nrecursively found in <code>path</code>.\n<p>It is expected that the …\n"],["load_v1","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_v1","()","<p>Loads a MIME::Types registry from files found in <code>path</code> that are\nin the v1 data format. The file search …\n"],["load_yaml","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_yaml","()","<p>Loads a MIME::Types registry from YAML files (<code>*.yml</code> or\n<code>*.yaml</code>) recursively found in <code>path</code>.\n<p>It is expected …\n"],["match","MIME::Types","MIME/Types.html#method-i-match","(pattern)",""],["new","MIME::Type","MIME/Type.html#method-c-new","(content_type)","<p>Builds a MIME::Type object from the provided MIME Content Type value (e.g.,\n‘text/plain’ or ‘applicaton/x-eruby’). …\n"],["new","MIME::Types","MIME/Types.html#method-c-new","()","<p>Creates a new MIME::Types registry.\n"],["new","MIME::Types::Loader","MIME/Types/Loader.html#method-c-new","(path = nil, container = nil)","<p>Creates a Loader object that can be used to load MIME::Types registries\ninto memory, using YAML, JSON …\n"],["obsolete?","MIME::Type","MIME/Type.html#method-i-obsolete-3F","()","<p>Returns <code>true</code> if the media type is obsolete.\n"],["of","MIME::Types","MIME/Types.html#method-i-of","(filename, platform = false)",""],["platform?","MIME::Type","MIME/Type.html#method-i-platform-3F","(__internal__ = false)","<p>Returns <code>true</code> if the MIME::Type is specific to the current\noperating system as represented by RUBY_PLATFORM …\n"],["priority_compare","MIME::Type","MIME/Type.html#method-i-priority_compare","(other)","<p>Compares the MIME::Type based on how reliable it is before doing a normal\n&lt;=&gt; comparison. Used …\n"],["prune_matches","MIME::Types","MIME/Types.html#method-i-prune_matches","(matches, flags)",""],["read_file","MIME::Types::Loader","MIME/Types/Loader.html#method-i-read_file","(filename)",""],["registered?","MIME::Type","MIME/Type.html#method-i-registered-3F","()","<p>Prior to BCP 178 (RFC 6648), it could be assumed that MIME content types\nthat start with <code>x-</code> were unregistered …\n"],["save","MIME::Types::Cache","MIME/Types/Cache.html#method-i-save","(types = nil, cache_file = nil)","<p>Attempts to save the types provided to the cache file provided.\n<p>If <code>types</code> is not provided or is <code>nil</code>, the …\n"],["signature?","MIME::Type","MIME/Type.html#method-i-signature-3F","()","<p>Returns <code>true</code> when the simplified MIME::Type is in the list of\nknown digital signatures.\n"],["system","MIME::Type","MIME/Type.html#method-i-system","()","<p>If the MIME::Type is a system-specific MIME::Type, returns the regular\nexpression for the operating system …\n"],["system?","MIME::Type","MIME/Type.html#method-i-system-3F","(__internal__ = false)","<p>Returns <code>true</code> if the MIME::Type is specific to an operating\nsystem.\n<p>This method is deprecated.\n"],["to_a","MIME::Type","MIME/Type.html#method-i-to_a","()","<p>Returns the MIME::Type as an array suitable for use with\nMIME::Type.from_array.\n<p>This method is deprecated. …\n"],["to_h","MIME::Type","MIME/Type.html#method-i-to_h","()","<p>Converts the MIME::Type to a hash suitable for use in JSON. The output of\nthis method can also be used …\n"],["to_hash","MIME::Type","MIME/Type.html#method-i-to_hash","()","<p>Returns the MIME::Type as an array suitable for use with\nMIME::Type.from_hash.\n<p>This method is deprecated. …\n"],["to_json","MIME::Type","MIME/Type.html#method-i-to_json","(*args)","<p>Converts the MIME::Type to a JSON string.\n"],["to_s","MIME::Type","MIME/Type.html#method-i-to_s","()","<p>Returns the MIME::Type as a string.\n"],["to_str","MIME::Type","MIME/Type.html#method-i-to_str","()","<p>Returns the MIME::Type as a string for implicit conversions. This allows\nMIME::Type objects to appear …\n"],["type_for","MIME::Types","MIME/Types.html#method-i-type_for","(filename, platform = false)","<p>Return the list of MIME::Types which belongs to the file based on its\nfilename extension. If there is …\n"],["urls","MIME::Type","MIME/Type.html#method-i-urls","()","<p>The decoded URL list for this MIME::Type.\n<p>The special URL value IANA will be translated into:\n\n<pre>http://www.iana.org/assignments/media-types/&lt;mediatype&gt;/&lt;subtype&gt;</pre>\n"],["use_instead","MIME::Type","MIME/Type.html#method-i-use_instead","()","<p>Returns the media type or types that should be used instead of this media\ntype, if it is obsolete. If …\n"],["v1_path","MIME::Types::Loader","MIME/Types/Loader.html#method-i-v1_path","()",""],["xref_urls","MIME::Type","MIME/Type.html#method-i-xref_urls","()","<p>The decoded cross-reference URL list for this MIME::Type.\n"],["yaml_path","MIME::Types::Loader","MIME/Types/Loader.html#method-i-yaml_path","()",""],["Contributing","","Contributing_rdoc.html","","<p>Contributing\n<p>I value any contribution to mime-types you can provide: a bug report, a\nfeature request, …\n"],["History-Types","","History-Types_rdoc.html","","<p>MIME Types Changes by Version\n<p>2.3 / 2014-05-23\n<p>Updated the IANA media registry entries as of release date. …\n"],["History","","History_rdoc.html","","<p>2.3 / 2014-05-23\n<p>Bugs:\n<p>Fixed a bug in <code>MIME::Types#type_for</code> where type specifications\nthat did not match …\n"],["Licence","","Licence_rdoc.html","","<p>Licence\n<p>This software is available under three licences: the GNU GPL version 2 (or\nat your option, a later …\n"],["Manifest","","Manifest_txt.html","","<p>.autotest .coveralls.yml .gemtest .hoerc .minitest.rb .travis.yml\nContributing.rdoc Gemfile History-Types.rdoc …\n"],["README","","README_rdoc.html","","<p>mime-types\n<p>home  &mdash; github.com/halostatue/mime-types/\n<p>code  &mdash; github.com/halostatue/mime-types/\n"],["COPYING","","docs/COPYING_txt.html","","<p>GNU GENERAL PUBLIC LICENSE\n\n<pre>                      Version 2, June 1991\n\nCopyright (C) 1989, 1991 Free Software ...</pre>\n"],["artistic","","docs/artistic_txt.html","","<p>The “Artistic License”\n\n<pre>        Preamble\n\nThe intent of this document is to state the conditions ...</pre>\n"]]}}